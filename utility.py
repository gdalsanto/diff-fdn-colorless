# Differentiable FDN for Colorless Reverberation 
# utility functions 

import torch
import torchaudio
import numpy as np
import os
import time
import shutil
import uuid
import scipy.io
import matplotlib.pylab as plt

def get_impulse_response(net, num):
    '''
    get impulse and magnitude resoponse generated by the learned parameters of FDN()
    Args    net (nn.Module): trained FDN() network
            num (int): number of frequnecy samples to evaluate the impulse response on
    Output  h (torch.tensor): FDN impulse response
            H (torch.tensor): FDN magnitude response
    '''
    in_signal = get_frequency_samples(num)
    H = net(in_signal)
    h = torch.fft.irfft(H)
    return h, H

def get_frequency_samples(num):
    '''
    get frequency samples (in radians) sampled at linearly spaced points along the unit circle
    Args    num (int): number of frequency samples
    Output  frequency samples in radians between [0, pi]
    '''
    # angle = torch.arange(0, 1+(1/num)/2, 1/num)
    # abs = torch.ones(num+1)
    angle = torch.linspace(0, 1, num)
    abs = torch.ones(num)
    return torch.polar(abs, angle * np.pi)    

def save_output(net, 
                path_dir,
                save_audio = False,
                samplerate = 48000,):
    '''
    create output directory and save FDN parameters from FDN() network and config file
    Args    net (nn.Module): trained FDN() network
            output_dir (string): path to output directory where a new dedicated folder will be created
            save_audio (bool): if true save impulse response as .wav file with sampling rate defined in samplerate
            samplerate (int): sampling rate
    Output  full_output_dir (string): path to dedicated output directory
            param (dictionary of tensors): FDN() net parameters 
            filename (string): filename of the audiofile if save_audio=True, None otherwise
    '''
    # create output folder
    if not os.path.exists(path_dir):
        os.makedirs(path_dir)
        path_dir = os.path.join('output', time.strftime("%Y%m%d-%H%M%S"))
        os.makedirs(path_dir)


    # save parameters
    param, _ = save_parametes(net, path_dir, filename='parameters.mat')

    filename = None
    if save_audio:
    # compute outputs
        [h,H] = get_impulse_response(net, samplerate)
        h_norm = h / torch.norm(h)
        # save outputs
        unique_str = str(uuid.uuid4())
        filename = os.path.join(path_dir, unique_str+'_output.wav')
        torchaudio.save(filename,
                        torch.stack((h_norm.squeeze(0),h_norm.squeeze(0)),1).detach().cpu().numpy(),
                        samplerate,
                        bits_per_sample=32,
                        channels_first=False)
    return path_dir, param, filename

def fdn2dir(net):
    '''
    save learnable parameters to a dictionary  
    Args    net (nn.Module): trained FDN() network
    Output  d (dictionary of tensors): FDN() net parameters 
    '''
    d = {} # enpty dictionary 
    for name, param in net.named_parameters():
        if param.requires_grad:
            d[name] = param.data 
    d['gain_per_sample'] = net.gain_per_sample
    d['N'] = net.N
    return d

def save_parametes(net, dir_path, filename):
    '''
    save parameters of FDN() net to .mat file 
    Args    net (nn.Module): trained FDN() network
            dir_path (string): path to output firectory
            filename (string): name of the file 
    Output  param (dictionary of tensors): FDN() net parameters
            param_np (dictionary of numpy arrays): FDN() net parameters
    '''
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)   
    
    param = fdn2dir(net)
    param_np = {}
    for name, value in param.items():
        if name == 'A.parametrizations.weight.original':
            name = 'A'
        if name == 'A1.parametrizations.weight.original':
            name = 'A1'
        if name == 'A2.parametrizations.weight.original':
            name = 'A2'
        if name == 'A3.parametrizations.weight.original':
            name = 'A3'
        try:
            param_np[name] = value.squeeze().cpu().numpy()
        except AttributeError:
            param_np[name] = value
    if ('m' not in param_np):
        param['m'] = net.m * net.mStd + net.mAvr     
        param_np['m'] = ( net.m * net.mStd + net.mAvr ).squeeze().cpu().numpy()  

    # save parameters in numpy format 
    scipy.io.savemat(os.path.join(dir_path, filename),
                     param_np)
    return param, param_np

def fdn2ft(param, num):
    '''
    computes the FDN magnitude response at linearly spaced frequuency samples
    Args    param (dictionary of tensors): FDN() net parameters
            num (int): number of frequnecy samples to evaluate the impulse response on
    Output  magnitude response of the FDN (torch.tensor)
    '''
    N = param['N']
    B = torch.complex(param['B'], torch.zeros(1,N,1))
    C = torch.complex(param['C'], torch.zeros(1,1,N))
    A = param['A.parametrizations.weight.original']
    gain_per_sample = param['gain_per_sample']
    m = param['m']
        
    x = get_frequency_samples(num)
    x = x.view(x.size(0), -1)
    D =  torch.diag_embed((x / gain_per_sample) ** m)
    H = torch.matmul(torch.matmul(C, torch.inverse(D - A)), B)
    
    return H.squeeze()

def save_loss(train_loss, valid_loss, output_dir, save_plot=True, filename=''):
    '''
    save training and validation loss values in .mat format
    Args    train_loss (list): training loss values at each epoch
            valid_loss (list): validation loss values at each epoch
            output_dir (string): path to output directory
            save_plot (bool): if True saves the plot of the losses in .pdf format
            filename (string): additional string to add before .pdf and .mat
    '''
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)  
        
    losses = {}
    losses['train'] = train_loss
    losses['valid'] = valid_loss
    n_epochs = len(train_loss)
    
    if save_plot:
        plt.plot(range(1,n_epochs+1), train_loss, label='training')
        plt.plot(range(1,n_epochs+1), valid_loss, label='validation')
        plt.legend()
        plt.xlabel('epoch n')
        plt.ylabel('loss')
        plt.savefig(os.path.join(output_dir,'losses'+filename+'.pdf'))
    scipy.io.savemat(os.path.join(output_dir,'losses'+filename+'.mat'), losses)
    
    
def move_item(current_path, dest_path):
    '''
    move item from current path to destination path
    Args   
        current_path (string): current path of the file
        dest_path (string): path of the file in the destination dir
    '''
    os.rename(current_path, dest_path)
    
def weights_init_normal(m):
    '''
    Takes in a module and initializes all linear layers with weight
        values taken from a normal distribution.
    '''

    classname = m.__class__.__name__
    # for every Linear layer in a model
    if classname.find('Linear') != -1:
        y = m.in_features * m.in_features
        # m.weight.data shoud be taken from a normal distribution
        m.weight.data.normal_(0.0,1/np.sqrt(y))
        # m.bias.data should be 0
        m.bias.data.fill_(0)

def energy_norm(m):
    '''
    Takes in a module and initializes all linear layers with weight
        values taken from a normal distribution.
    '''

    classname = m.__class__.__name__
    # for every Linear layer in a model
    if classname.find('Parameter') != -1:
        y = m.in_features * m.in_features
    # m.weight.data shoud be taken from a normal distribution
        # m.weight.data.normal_(0.0,1/np.sqrt(y))
        m.weight.data.normal_(0.0,1/np.sqrt(y))
    # m.bias.data should be 0
        m.bias.data.fill_(0)

def get_str_results(epoch=None, train_loss=None, valid_loss=None, time=None, lossF = None, lossT = None):
    '''construct the string that has to be print at the end of the epoch'''
    to_print=''

    if epoch is not None:
        to_print += 'epoch: {:3d} '.format(epoch)
    
    if train_loss is not None:
        to_print += '- train_loss: {:6.4f} '.format(train_loss[-1])
                        
    if valid_loss is not None:
        to_print += '- test_loss: {:6.4f} '.format(valid_loss[-1])

    if time is not None:
        to_print += '- time: {:6.4f} s'.format(time)

    if lossF is not None:
        to_print += '- lossF: {:6.4f}'.format(lossF) 

    if lossT is not None:
        to_print += '- lossT: {:6.4f}'.format(lossT) 

    return to_print

def skew_matrix(X):
    # compute skew symmetric matrix 
    A = X.triu(1)
    return A - A.transpose(-1, -2)


